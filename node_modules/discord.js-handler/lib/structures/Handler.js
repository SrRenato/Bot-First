"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const path_1 = require("path");
const chalk_1 = require("chalk");
const CommandsCache_1 = require("./CommandsCache");
const CooldownManager_1 = require("./CooldownManager");
const handler_1 = require("../declarations/handler");
const { lstat, readdir } = fs_1.promises;
class Handler extends handler_1.HandlerBase {
    constructor(options) {
        super();
        this.login = async () => {
            try {
                await this.client.login(this.token);
            }
            catch (e) {
                throw chalk_1.red('Invalid token or Discord API down');
            }
        };
        this.run = async () => {
            try {
                const joinFolder = (...folder) => path_1.join(this.moduleFolder, ...folder);
                const checkFolderScan = async (type) => {
                    const folder = type === 'events' ? this.eventsFolder : this.commandsFolder;
                    if (!folder)
                        return;
                    await this.scanFolder(joinFolder(folder), type);
                    const finalizersFolder = await readdir(joinFolder(this.finalizersFolder));
                    if (!finalizersFolder || finalizersFolder.length === 0)
                        return;
                    const options = { client: this.client, handler: this, cache: CommandsCache_1.default };
                    for (let i = 0; i < finalizersFolder.length; i++) {
                        const finalizerImport = await Promise.resolve().then(() => require(joinFolder(this.finalizersFolder, finalizersFolder[i])));
                        const FinalizerClass = finalizerImport.default || finalizerImport;
                        const { listener, type: finalizerType } = new FinalizerClass();
                        if (type === 'events' && finalizerType === 'event')
                            await listener(options);
                        if (type === 'commands' && finalizerType === 'command')
                            await listener(options);
                    }
                };
                await checkFolderScan('events');
                await checkFolderScan('commands');
            }
            catch (e) {
                console.error(e);
            }
        };
        this.scanFolder = async (path, type) => {
            try {
                if (!(await lstat(path)).isDirectory())
                    throw chalk_1.red(`The path ${path} is a file. It must be a directory`);
                const files = await readdir(path);
                const categoryRelativePath = path.substring(this.moduleFolder.length + 1);
                if (type === 'commands' && categoryRelativePath !== type) {
                    const categoryName = categoryRelativePath.substring((categoryRelativePath.lastIndexOf('\\') || categoryRelativePath.lastIndexOf('/')) + 1);
                    const commandNames = files.map((file) => file.substring(0, file.lastIndexOf('.')));
                    CommandsCache_1.default.categories.set(categoryName, commandNames);
                }
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    const newFullPath = path_1.join(path, file);
                    if ((await lstat(newFullPath)).isDirectory()) {
                        await this.scanFolder(newFullPath, type);
                        continue;
                    }
                    if (!file.endsWith('.js') && !file.endsWith('.ts'))
                        continue;
                    const fileContent = await Promise.resolve().then(() => require(newFullPath));
                    const ListenerClass = fileContent.default || fileContent;
                    if (!ListenerClass)
                        continue;
                    const importedListener = new ListenerClass();
                    const { listener } = importedListener;
                    if (type === 'events') {
                        const { name } = importedListener;
                        const callbackDefaultParams = {
                            client: this.client,
                            handler: this,
                            cache: CommandsCache_1.default,
                        };
                        const callback = listener.bind(importedListener, callbackDefaultParams, this.importCommands);
                        this.client.on(name, callback);
                        if (this.verbose)
                            console.log(chalk_1.green(`[HANDLER] Event ${name} loaded`));
                    }
                    else if (type === 'commands') {
                        const { aliases: _aliases } = importedListener;
                        const aliases = _aliases.map((a) => a.toLowerCase());
                        CommandsCache_1.default.commands.set(aliases, listener);
                        const setToCache = (param) => {
                            const value = importedListener[param];
                            if (value)
                                CommandsCache_1.default.properties[param].set(aliases, value);
                        };
                        const props = Object.keys(CommandsCache_1.default.properties);
                        for (let j = 0; j < props.length; j++)
                            setToCache(props[j]);
                        if (this.verbose)
                            console.log(chalk_1.green(`[HANDLER] Command [${aliases.join(', ')}] loaded`));
                    }
                }
            }
            catch (e) {
                console.error(e);
            }
        };
        this.importCommands = async (prefix, message) => {
            try {
                const args = message.content.split(' ');
                const commandName = args.shift().slice(prefix.length);
                const compatibleCommandName = commandName.toLowerCase();
                if (!message.content.startsWith(prefix))
                    return;
                const { client } = this;
                const allArguments = {
                    commandName,
                    args,
                    prefix,
                    message,
                    client,
                    handler: this,
                    cache: CommandsCache_1.default,
                };
                const genericLikeArguments = { client, handler: this, cache: CommandsCache_1.default };
                const { properties: { locations, permissions, cooldowns, syntax }, commands, findSelfProperty, } = CommandsCache_1.default;
                const locationsProp = findSelfProperty(locations, compatibleCommandName);
                if (locationsProp) {
                    const { locationType, notLocationCallback } = locationsProp;
                    if (locationType === 'dm' && message.channel.type !== 'dm')
                        return notLocationCallback(genericLikeArguments, message);
                    if (locationType === 'server' && message.channel.type === 'dm')
                        return notLocationCallback(genericLikeArguments, message);
                }
                const permissionsProp = findSelfProperty(permissions, compatibleCommandName);
                if (permissionsProp) {
                    const { permissionCheck, noPermissionCallback } = permissionsProp;
                    if ((typeof permissionCheck === 'function' && !(await permissionCheck(allArguments))) ||
                        (typeof permissionCheck === 'string' && !message.member.hasPermission(permissionCheck)))
                        return noPermissionCallback(genericLikeArguments, message);
                }
                const cooldownProp = findSelfProperty(cooldowns, compatibleCommandName);
                if (cooldownProp) {
                    const { cooldownIds } = CooldownManager_1.default;
                    const { cooldownLeftCallback, cooldownTime } = cooldownProp;
                    const authorId = message.author.id;
                    if (cooldownIds.has(authorId))
                        return cooldownLeftCallback(genericLikeArguments, message);
                    cooldownIds.add(authorId);
                    setTimeout(() => cooldownIds.delete(authorId), cooldownTime);
                }
                const syntaxProp = findSelfProperty(syntax, compatibleCommandName);
                let syntaxValidation = false;
                if (syntaxProp) {
                    const rawArgs = args.map((arg) => arg.replace(/[^a-z0-9 ]/gi, ''));
                    for (let i = 0; i < syntaxProp.length; i++) {
                        const syntaxChunk = syntaxProp[i];
                        if (args.length < syntaxChunk.filter((c) => c.required !== false).length || args.length > syntaxChunk.length)
                            continue;
                        let passedArgs = 0;
                        for (let j = 0; j < syntaxChunk.length; j++) {
                            const { type, onlyMention, required, position } = syntaxChunk[j];
                            const [argReference, rawArgReference] = [args[position], rawArgs[position]];
                            if (!argReference) {
                                if (required === false)
                                    continue;
                                else
                                    break;
                            }
                            const foundMentionTypes = [];
                            for (let k = 0; k < type.length; k++) {
                                const selectedType = type[k];
                                const propName = `${selectedType}s`;
                                if ((selectedType !== 'plain' && message.guild[propName].cache.has(rawArgReference)) ||
                                    rawArgReference === argReference)
                                    foundMentionTypes.push(selectedType);
                            }
                            if (!foundMentionTypes.length ||
                                (foundMentionTypes.every((mentionType) => !type.includes(mentionType)) && !type.includes('plain')) ||
                                (argReference === rawArgReference && onlyMention && !type.includes('plain')))
                                break;
                            passedArgs += 1;
                        }
                        if (passedArgs === args.length)
                            syntaxValidation = true;
                    }
                }
                if (!syntaxValidation)
                    return;
                const commandCallback = findSelfProperty(commands, compatibleCommandName);
                if (commandCallback)
                    await commandCallback(allArguments);
            }
            catch (e) {
                console.error(e);
            }
        };
        Object.assign(this, options);
    }
}
exports.default = Handler;
